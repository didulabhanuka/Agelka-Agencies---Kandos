// models/inventory/item.model.js
const mongoose = require("mongoose");
const { Schema, model, Types } = mongoose;

// Item master schema supporting single-UOM and multi-UOM configurations.
const itemSchema = new Schema({
  itemCode: { type: String, unique: true, required: true, trim: true },
  name: { type: String, trim: true },
  description: { type: String, required: true, trim: true },
  brand: { type: Types.ObjectId, ref: "Brand", required: false },
  productGroup: { type: Types.ObjectId, ref: "ProductGroup", required: false },
  supplier: { type: Types.ObjectId, ref: "Supplier", required: false },

  // UOM setup: Mode A = primary only, Mode B = primary + base + hierarchy.
  primaryUom: { type: String, trim: true, required: true },
  baseUom: { type: String, trim: true, default: null },

  // UOM hierarchy used for conversion (empty in single-UOM mode).
  uoms: {
    type: [{
      uomCode: { type: String, required: true },
      parentCode: { type: String, default: null },
      factorToParent: { type: Number, required: true },
    }],
    default: [],
  },

  // Primary UOM pricing fields.
  avgCostPrimary: { type: Number, default: 0 },
  sellingPricePrimary: { type: Number, default: 0 },

  // Base UOM pricing fields (used/calculated in multi-UOM mode).
  avgCostBase: { type: Number, default: 0 },
  sellingPriceBase: { type: Number, default: 0 },

  // Precomputed conversion factor: how many base units are in 1 primary unit.
  factorToBase: { type: Number, default: 1 },

  reorderLevel: { type: Number, default: 0 },
  status: { type: String, enum: ["active", "inactive"], default: "active" },
  autoGenerated: { type: Boolean, default: false },
}, { timestamps: true });

// Enforce unique item code per brand combination.
itemSchema.index({ itemCode: 1, brand: 1 }, { unique: true });

// Validates UOM configuration and computes factor/prices before saving.
itemSchema.pre("save", async function (next) {
  try {
    if (!this.primaryUom) throw new Error("primaryUom is required");

    const uoms = this.uoms || [];
    const hasBaseUom = !!this.baseUom;

    // Mode A: primary-only item (no base UOM hierarchy).
    if (!hasBaseUom) {
      this.baseUom = null;
      this.uoms = [];
      this.factorToBase = 1;
      return next();
    }

    // Mode B: primary + base UOM requires a valid hierarchy.
    if (!Array.isArray(uoms) || uoms.length === 0) {
      throw new Error("UOM hierarchy (uoms array) is required when baseUom is provided");
    }

    const uomMap = {};
    let hasCycle = false;

    // Validate UOM entries and detect circular parent references.
    for (let uom of uoms) {
      if (!uom.uomCode) throw new Error("uomCode is required for each UOM entry");
      if (uom.factorToParent <= 0) throw new Error(`Invalid factorToParent value for UOM: ${uom.uomCode}`);

      uomMap[uom.uomCode] = uom;

      let parentCode = uom.parentCode;
      while (parentCode) {
        if (parentCode === uom.uomCode) {
          hasCycle = true;
          break;
        }
        parentCode = uomMap[parentCode]?.parentCode;
      }

      if (hasCycle) throw new Error(`Circular reference detected in UOM hierarchy for: ${uom.uomCode}`);
    }

    // Ensure both primary and base UOMs are declared in the hierarchy.
    const primaryExists = uoms.some((u) => u.uomCode === this.primaryUom);
    const baseExists = uoms.some((u) => u.uomCode === this.baseUom);

    if (!primaryExists) throw new Error(`primaryUom '${this.primaryUom}' is not defined in uoms array`);
    if (!baseExists) throw new Error(`baseUom '${this.baseUom}' is not defined in uoms array`);

    // Compute conversion factor from primary UOM to base UOM.
    this.factorToBase = await calculateFactorToBase(this.primaryUom, this.baseUom, uoms);

    // Auto-calculate base prices only when not explicitly provided.
    if (this.avgCostPrimary && !this.avgCostBase) this.avgCostBase = this.avgCostPrimary / this.factorToBase;
    if (this.sellingPricePrimary && !this.sellingPriceBase) this.sellingPriceBase = this.sellingPricePrimary / this.factorToBase;

    next();
  } catch (err) {
    next(err);
  }
});

module.exports = model("Item", itemSchema);

// Calculates factorToBase as the number of baseUom units contained in 1 primaryUom.
async function calculateFactorToBase(primaryUomCode, baseUomCode, uoms = []) {
  if (!primaryUomCode || !baseUomCode) {
    throw new Error("Both primaryUom and baseUom are required to calculate factorToBase");
  }

  const uomMap = {};
  uoms.forEach((u) => {
    if (!u.uomCode) return;
    uomMap[u.uomCode] = u;
  });

  const primary = uomMap[primaryUomCode];
  const base = uomMap[baseUomCode];

  if (!primary) throw new Error(`Primary UOM not found in uoms: ${primaryUomCode}`);
  if (!base) throw new Error(`Base UOM not found in uoms: ${baseUomCode}`);

  // Walk from base up to primary, multiplying factorToParent at each step.
  let factorToBase = 1;
  let currentUOM = base;

  while (currentUOM && currentUOM.uomCode !== primaryUomCode) {
    if (!currentUOM.parentCode) {
      throw new Error(`Base UOM ${baseUomCode} is not under primary UOM ${primaryUomCode} in the hierarchy`);
    }

    const parentUOM = uomMap[currentUOM.parentCode];
    if (!parentUOM) throw new Error(`Parent UOM not found: ${currentUOM.parentCode}`);

    const f = Number(currentUOM.factorToParent || 0);
    if (!Number.isFinite(f) || f <= 0) throw new Error(`Invalid factorToParent for UOM: ${currentUOM.uomCode}`);

    factorToBase *= f;
    currentUOM = parentUOM;
  }

  if (currentUOM?.uomCode !== primaryUomCode) {
    throw new Error(`Base UOM ${baseUomCode} is not reachable from primary UOM ${primaryUomCode}`);
  }

  return factorToBase;
}