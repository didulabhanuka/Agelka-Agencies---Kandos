// // models/product/Item.model.js
// const { Schema, model, Types } = require('mongoose');

// const itemSchema = new Schema(
//   {
//     itemCode:    { type: String, unique: true, required: true, trim: true },
//     name:        { type: String, trim: true },
//     description: { type: String, required: true, trim: true },

//     brand:        { type: Types.ObjectId, ref: 'Brand', required: false },
//     productGroup: { type: Types.ObjectId, ref: 'ProductGroup', required: false },

//     // NEW: unit is now selected from ProductGroup.units (string)
//     unit: { type: String, trim: true },

//     supplier: { type: Types.ObjectId, ref: 'Supplier', required: false },

//     // Removed unit/sub-unit logic, only base prices used now
//     avgCostBase:      { type: Number, default: 0 },
//     sellingPriceBase: { type: Number, default: 0 },

//     reorderLevel: { type: Number, default: 0 },
//     status:       { type: String, enum: ['active', 'inactive'], default: 'active' },
//     autoGenerated: { type: Boolean, default: false },
//   },
//   { timestamps: true }
// );

// // still ensure itemCode+brand unique
// itemSchema.index({ itemCode: 1, brand: 1 }, { unique: true });

// module.exports = model('Item', itemSchema);







const mongoose = require("mongoose");
const { Schema, model, Types } = mongoose;

// Item schema
const itemSchema = new Schema(
  {
    itemCode: { type: String, unique: true, required: true, trim: true },
    name: { type: String, trim: true },
    description: { type: String, required: true, trim: true },
    brand: { type: Types.ObjectId, ref: "Brand", required: false },
    productGroup: { type: Types.ObjectId, ref: "ProductGroup", required: false },
    supplier: { type: Types.ObjectId, ref: "Supplier", required: false },

    // Primary and Base UOM
    // ✅ MODE A: primaryUom only (single-UOM item)
    // ✅ MODE B: primaryUom + baseUom + uoms[] (multi-UOM item)
    primaryUom: { type: String, trim: true, required: true },
    baseUom: { type: String, trim: true, default: null }, // <-- optional now

    // Define UOM hierarchy and conversion factors
    // In MODE A: this will stay []
    uoms: {
      type: [
        {
          uomCode: { type: String, required: true },
          parentCode: { type: String, default: null },
          factorToParent: { type: Number, required: true },
        },
      ],
      default: [],
    },

    // Primary UOM prices and base UOM prices
    avgCostPrimary: { type: Number, default: 0 }, // Primary UOM cost
    sellingPricePrimary: { type: Number, default: 0 }, // Primary UOM price

    // In MODE A: these are not used (no calculations)
    // In MODE B: auto-calculated if not provided
    avgCostBase: { type: Number, default: 0 },
    sellingPriceBase: { type: Number, default: 0 },

    // Factor to Base UOM (pre-calculated conversion factor)
    // ✅ MODE A: 1 (no separate base; 1 primary = 1 base-equivalent)
    // ✅ MODE B: how many baseUom units per 1 primaryUom
    factorToBase: { type: Number, default: 1 },

    reorderLevel: { type: Number, default: 0 },
    status: { type: String, enum: ["active", "inactive"], default: "active" },
    autoGenerated: { type: Boolean, default: false },
  },
  { timestamps: true }
);

// Ensuring itemCode + brand is unique across the system
itemSchema.index({ itemCode: 1, brand: 1 }, { unique: true });

// Validation and other logic
itemSchema.pre("save", async function (next) {
  try {
    // primaryUom is always required
    if (!this.primaryUom) {
      throw new Error("primaryUom is required");
    }

    const uoms = this.uoms || [];
    const hasBaseUom = !!this.baseUom; // if user entered baseUom => MODE B

    // =====================================================
    // MODE A — ONLY PRIMARY UOM (no baseUom)
    // =====================================================
    if (!hasBaseUom) {
      // User did NOT provide baseUom => single-UOM item
      this.baseUom = null;
      this.uoms = [];          // ignore any stray uoms
      this.factorToBase = 1;   // 1 primary = 1 base-equivalent

      // No base price calculations needed; keep defaults / whatever user sent
      // this.avgCostBase = this.avgCostBase || 0;
      // this.sellingPriceBase = this.sellingPriceBase || 0;

      return next();
    }

    // =====================================================
    // MODE B — PRIMARY + BASE UOM (full multi-UOM pipeline)
    // =====================================================

    if (!Array.isArray(uoms) || uoms.length === 0) {
      throw new Error(
        "UOM hierarchy (uoms array) is required when baseUom is provided"
      );
    }

    const uomMap = {};
    let hasCycle = false;

    // Basic validation: check for circular references and factorToParent > 0
    for (let uom of uoms) {
      if (!uom.uomCode) {
        throw new Error("uomCode is required for each UOM entry");
      }

      if (uom.factorToParent <= 0) {
        throw new Error(`Invalid factorToParent value for UOM: ${uom.uomCode}`);
      }

      // Save into map (last definition wins, but we assume unique uomCode per item)
      uomMap[uom.uomCode] = uom;

      let parentCode = uom.parentCode;
      // Detect simple self-cycle via parent chain already in map
      while (parentCode) {
        if (parentCode === uom.uomCode) {
          hasCycle = true;
          break;
        }
        parentCode = uomMap[parentCode]?.parentCode;
      }

      if (hasCycle) {
        throw new Error(
          `Circular reference detected in UOM hierarchy for: ${uom.uomCode}`
        );
      }
    }

    // Ensure primaryUom and baseUom exist in uoms[]
    const primaryExists = uoms.some((u) => u.uomCode === this.primaryUom);
    const baseExists = uoms.some((u) => u.uomCode === this.baseUom);

    if (!primaryExists) {
      throw new Error(
        `primaryUom '${this.primaryUom}' is not defined in uoms array`
      );
    }
    if (!baseExists) {
      throw new Error(
        `baseUom '${this.baseUom}' is not defined in uoms array`
      );
    }

    // Recalculate the factorToBase:
    // factorToBase = how many base units per 1 primary unit
    const factorToBase = await calculateFactorToBase(
      this.primaryUom,
      this.baseUom,
      uoms
    );
    this.factorToBase = factorToBase;

    // Recalculate prices ONLY if base prices are missing
    if (this.avgCostPrimary && !this.avgCostBase) {
      this.avgCostBase = this.avgCostPrimary / this.factorToBase;
    }
    if (this.sellingPricePrimary && !this.sellingPriceBase) {
      this.sellingPriceBase = this.sellingPricePrimary / this.factorToBase;
    }

    next();
  } catch (err) {
    next(err);
  }
});

module.exports = model("Item", itemSchema);

/**
 * Helper function to calculate factorToBase based on UOM hierarchy
 *
 * ✅ primaryUomCode: root / main unit (e.g. "PACK")
 * ✅ baseUomCode: smallest / derived unit (e.g. "PCS")
 * ✅ uoms: array describing the tree
 *
 * factorToBase = "how many baseUom units are in 1 primaryUom"
 *
 * We walk from BASE up to PRIMARY, multiplying factorToParent at each step.
 */
async function calculateFactorToBase(primaryUomCode, baseUomCode, uoms = []) {
  if (!primaryUomCode || !baseUomCode) {
    throw new Error(
      "Both primaryUom and baseUom are required to calculate factorToBase"
    );
  }

  const uomMap = {};
  uoms.forEach((u) => {
    if (!u.uomCode) return;
    uomMap[u.uomCode] = u;
  });

  const primary = uomMap[primaryUomCode];
  const base = uomMap[baseUomCode];

  if (!primary) {
    throw new Error(`Primary UOM not found in uoms: ${primaryUomCode}`);
  }
  if (!base) {
    throw new Error(`Base UOM not found in uoms: ${baseUomCode}`);
  }

  // Walk from BASE up to PRIMARY, multiplying factorToParent
  let factorToBase = 1;
  let currentUOM = base;

  while (currentUOM && currentUOM.uomCode !== primaryUomCode) {
    if (!currentUOM.parentCode) {
      throw new Error(
        `Base UOM ${baseUomCode} is not under primary UOM ${primaryUomCode} in the hierarchy`
      );
    }

    const parentUOM = uomMap[currentUOM.parentCode];
    if (!parentUOM) {
      throw new Error(`Parent UOM not found: ${currentUOM.parentCode}`);
    }

    // factorToParent = how many of THIS UOM per 1 parent UOM
    const f = Number(currentUOM.factorToParent || 0);
    if (!Number.isFinite(f) || f <= 0) {
      throw new Error(`Invalid factorToParent for UOM: ${currentUOM.uomCode}`);
    }

    factorToBase *= f;
    currentUOM = parentUOM;
  }

  if (currentUOM?.uomCode !== primaryUomCode) {
    throw new Error(
      `Base UOM ${baseUomCode} is not reachable from primary UOM ${primaryUomCode}`
    );
  }

  return factorToBase;
}
